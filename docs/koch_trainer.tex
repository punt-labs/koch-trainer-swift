%
% koch_trainer.tex
%
% Z Specification for Koch Trainer
% Formal model of a Morse code learning application using the Koch method
%

\documentclass[a4paper,10pt,fleqn]{article}
\usepackage[margin=1in]{geometry}
\usepackage{amssymb}
\usepackage[colorlinks=true,linkcolor=blue,citecolor=blue,urlcolor=blue]{hyperref}
\usepackage{fuzz}
\usepackage{zed-maths}
\usepackage{zed-proof}

\begin{document}

\title{Koch Trainer: A Z Specification}
\author{Formal Model of Morse Code Learning Progress}
\date{January 2026}
\hypersetup{
  pdftitle={Koch Trainer: A Z Specification},
  pdfauthor={Formal Model of Morse Code Learning Progress},
  pdfsubject={Z Specification for Morse Code Learning},
  pdfcreator={fuzz/probcli}
}
\maketitle

\tableofcontents
\newpage

%==============================================================================
\section{Introduction}
%==============================================================================

Koch Trainer teaches Morse code using the \emph{Koch method}---a proven technique
developed by German psychologist Ludwig Koch in the 1930s. Rather than learning
Morse at slow speeds and gradually increasing, students learn characters at full
speed (20 words per minute) from the start, adding one new character at a time
after achieving 90\% accuracy.

\subsection{Design Philosophy}

The application follows four core principles:

\begin{enumerate}
\item \textbf{Audio-first}: Morse code is fundamentally an auditory skill. Visual
      aids support learning, but audio remains primary.

\item \textbf{Spaced repetition}: Practice intervals adapt to performance,
      maximizing long-term retention while minimizing daily time commitment.

\item \textbf{Separate skills}: Receiving (copying audio to text) and sending
      (keying Morse from text) are distinct skills that progress independently.

\item \textbf{Realistic simulation}: QSO practice mirrors real amateur radio
      operation with authentic timing and protocols.
\end{enumerate}

\subsection{Scope of This Specification}

This formal specification models the stateful components of the learning system:

\begin{itemize}
\item Student progress through 26 Koch-ordered characters
\item Per-character accuracy statistics by training direction
\item Spaced repetition scheduling with adaptive intervals
\item Streak tracking for consecutive practice days
\end{itemize}

We do not model audio generation, UI state, or real-time session mechanics---only
the persistent state that survives between sessions.

%==============================================================================
\section{Basic Types}
%==============================================================================

We introduce given sets for entities whose internal structure is irrelevant to
the learning model.

\begin{zed}
[SESSIONID, TIMESTAMP]
\end{zed}

$SESSIONID$ uniquely identifies completed training sessions.
$TIMESTAMP$ represents points in time for scheduling and history tracking.

Note: We do not model individual Morse characters as a given set. The 26 letters
follow a fixed Koch order (K M R S U A P T L O W I N J E F Y V G Q Z H B C D X),
and level numbers 1--26 implicitly identify the character set unlocked at each level.

%==============================================================================
\section{Free Types}
%==============================================================================

\subsection{Training Direction}

Training occurs in two distinct directions, each developing a different skill:

\begin{zed}
Direction ::= receive | send
\end{zed}

In \emph{receive} mode, the student hears Morse audio and types the corresponding
letter---training auditory pattern recognition. In \emph{send} mode, the student
sees a letter and keys the Morse pattern using dit/dah inputs---training motor
memory and timing.

These skills progress independently. A student may excel at receiving while
struggling with sending, or vice versa. Separate tracking prevents frustration
and allows focused practice on weaker skills.

\subsection{Boolean Type}

We define a boolean type for input flags, using names that avoid conflicts
with ProB's reserved keywords:

\begin{zed}
ZBOOL ::= ztrue | zfalse
\end{zed}

\subsection{Radio Mode}

Amateur radio is half-duplex: the operator either receives (listens to incoming
signals) or transmits (sends outgoing signals), but not both simultaneously.
This fundamental constraint shapes the audio experience during training.

\begin{zed}
RadioMode ::= off | receiving | transmitting
\end{zed}

\begin{itemize}
\item \emph{off}: Radio not active (session not started, paused, or completed)
\item \emph{receiving}: Radio on, listening---continuous noise floor with
      band conditions (QRN, QSB, QRM), incoming Morse signals audible
\item \emph{transmitting}: Radio on, sending---sidetone only, receiver muted
      (no noise or band conditions)
\end{itemize}

When the radio is on and the operator is not transmitting, they are receiving.
This models real amateur radio behavior where the receiver is always active
unless explicitly transmitting.

\subsection{Session Phase}

A training session progresses through distinct phases:

\begin{zed}
SessionPhase ::= idle | introduction | training | paused | completed
\end{zed}

\begin{itemize}
\item \emph{idle}: No active session (initial state or session cancelled)
\item \emph{introduction}: Showing unlocked characters with audio playback
\item \emph{training}: Active call-and-response practice
\item \emph{paused}: Session suspended mid-training
\item \emph{completed}: Session ended with results ready to record
\end{itemize}

%==============================================================================
\section{Global Constants}
%==============================================================================

The Koch method uses exactly 26 letters introduced in a specific order based on
Ludwig Koch's research on optimal learning sequences. Characters are introduced
one at a time: level 1 unlocks only K, level 2 adds M, and so on.

\begin{axdef}
maxLevel : \nat \\
minLevel : \nat \\
maxInterval : \nat \\
minInterval : \nat \\
advanceThreshold : \nat \\
habitFormationDays : \nat \\
habitMaxInterval : \nat \\
missedPracticeMultiplier : \nat
\where
maxLevel = 26 \\
minLevel = 1 \\
maxInterval = 30 \\
minInterval = 1 \\
advanceThreshold = 90 \\
habitFormationDays = 14 \\
habitMaxInterval = 2 \\
missedPracticeMultiplier = 2
\end{axdef}

The advancement threshold of 90\% accuracy over a minimum of 20 attempts ensures
students have truly mastered current characters before encountering new ones.
This high bar is intentional: the Koch method's effectiveness depends on
learning characters correctly at full speed from the start.

\subsection{Model Bounds}

The following constants exist solely to enable finite model checking and animation
with probcli. They are \emph{not} system constraints---the application does not
enforce these limits. Values are chosen small enough for practical state space
exploration.

\begin{axdef}
MODEL\_BOUND : \nat
\where
MODEL\_BOUND = 3
\end{axdef}

When this specification refers to $MODEL\_BOUND$, understand that the constraint
exists for the model checker, not the implementation.

\subsection{Session Constants}

\begin{axdef}
proficiencyThreshold : \nat \\
baseMinimumAttempts : \nat \\
attemptsPerCharacter : \nat \\
responseTimeoutMs : \nat
\where
proficiencyThreshold = 90 \\
baseMinimumAttempts = 15 \\
attemptsPerCharacter = 5 \\
responseTimeoutMs = 3000
\end{axdef}

The proficiency threshold (90\%) matches the level advancement threshold.
Minimum attempts scale with character count: $\max(15, 5 \times characterCount)$.

%==============================================================================
\section{Character Statistics}
%==============================================================================

The system tracks per-character accuracy separately for each training direction.
This granular tracking serves multiple purposes:

\begin{itemize}
\item Identify specific characters that need more practice
\item Display proficiency indicators (color-coded rings) on the character grid
\item Enable future features like adaptive character selection
\end{itemize}

\begin{schema}{CharacterStat}
receiveAttempts : \nat \\
receiveCorrect : \nat \\
sendAttempts : \nat \\
sendCorrect : \nat \\
earAttempts : \nat \\
earCorrect : \nat
\where
receiveCorrect \leq receiveAttempts \\
sendCorrect \leq sendAttempts \\
earCorrect \leq earAttempts \\
receiveAttempts \leq MODEL\_BOUND \\
sendAttempts \leq MODEL\_BOUND \\
earAttempts \leq MODEL\_BOUND
\end{schema}

The invariants ensure that correct counts never exceed attempt counts---a
fundamental data integrity property. The $MODEL\_BOUND$ constraints enable
finite model checking; the application does not enforce these limits.

The \emph{earAttempts} and \emph{earCorrect} fields track ear training mode,
where students reproduce heard patterns rather than identify letters.

Combined accuracy for display purposes is computed as:
\[
accuracy = \frac{receiveCorrect + sendCorrect}{receiveAttempts + sendAttempts}
\]

%==============================================================================
\section{Session Result}
%==============================================================================

Each completed training session produces an immutable result record.

\begin{schema}{SessionResult}
sessionId : SESSIONID \\
direction : Direction \\
totalAttempts : \nat \\
correctCount : \nat \\
timestamp : TIMESTAMP
\where
correctCount \leq totalAttempts \\
totalAttempts \leq MODEL\_BOUND
\end{schema}

Session results form the historical record used for:
\begin{itemize}
\item Calculating streak continuity (did the student practice yesterday?)
\item Tracking long-term progress trends
\item Supporting future analytics features
\end{itemize}

Only \emph{learn mode} sessions (not custom practice or vocabulary drills)
affect level advancement and spaced repetition intervals.

%==============================================================================
\section{Student Progress}
%==============================================================================

The central state schema captures all persistent student progress. We flatten
the schedule fields into the main state for ProB animation compatibility.

\begin{schema}{StudentProgress}
receiveLevel : \nat \\
sendLevel : \nat \\
earLevel : \nat \\
sessionCount : \nat \\
receiveInterval : \nat \\
sendInterval : \nat \\
currentStreak : \nat \\
longestStreak : \nat
\where
receiveLevel \geq minLevel \\
receiveLevel \leq maxLevel \\
sendLevel \geq minLevel \\
sendLevel \leq maxLevel \\
earLevel \geq 1 \\
earLevel \leq 5 \\
sessionCount \leq MODEL\_BOUND \\
receiveInterval \geq minInterval \\
receiveInterval \leq maxInterval \\
sendInterval \geq minInterval \\
sendInterval \leq maxInterval \\
currentStreak \leq longestStreak \\
longestStreak \leq MODEL\_BOUND
\end{schema}

\subsection{Level Semantics}

Each level $n$ unlocks the first $n$ characters in Koch order:
\begin{itemize}
\item Level 1: K
\item Level 2: K, M
\item Level 3: K, M, R
\item $\vdots$
\item Level 26: All 26 letters
\end{itemize}

Receive and send levels progress independently. A student at receive level 15
and send level 8 can copy 15 characters but only send 8.

\subsection{Interval Semantics}

The \emph{receiveInterval} and \emph{sendInterval} fields represent the number
of days until the next scheduled practice for each direction. These intervals
adapt based on performance, implementing a simplified spaced repetition algorithm.

\subsection{Streak Semantics}

The streak tracks consecutive \emph{calendar days} with at least one completed
session (either direction counts). The longest streak persists as a personal
record for motivation.

%==============================================================================
\section{Training Session}
%==============================================================================

Training session state is separate from persistent student progress. In the
implementation, this lives in the ViewModel; here we model it as a distinct
schema.

\begin{schema}{TrainingSession}
phase : SessionPhase \\
direction : Direction \\
radioMode : RadioMode \\
toneActive : ZBOOL \\
characterCount : \nat \\
introIndex : \nat \\
sessionAttempts : \nat \\
sessionCorrect : \nat
\where
characterCount \geq 1 \\
characterCount \leq maxLevel \\
introIndex \leq characterCount \\
sessionCorrect \leq sessionAttempts \\
sessionAttempts \leq MODEL\_BOUND \\
% Radio mode constraints (half-duplex behavior)
phase \in \{idle, introduction, paused, completed\} \implies radioMode = off \\
(phase = training \land direction = receive) \implies radioMode = receiving \\
radioMode = transmitting \implies direction = send \\
% Tone constraints
radioMode = off \implies toneActive = zfalse
\end{schema}

The \emph{characterCount} is the number of unlocked characters for this session's
direction (equal to the current level). The \emph{introIndex} tracks progress
through the introduction phase.

The \emph{radioMode} models half-duplex radio behavior:
\begin{itemize}
\item During introduction, pause, or completion: radio is off (no audio)
\item During receive training: radio always receiving (user listens to incoming Morse)
\item During send training: user toggles between receiving (waiting) and transmitting (keying)
\item Transmitting is only valid in send mode (cannot transmit during receive training)
\end{itemize}

%==============================================================================
\section{Koch Trainer State}
%==============================================================================

The complete machine state combines persistent student progress with training
session state. Defining this as an explicit schema (rather than using schema
conjunction) ensures ProB tracks all variables during animation.

\begin{schema}{KochTrainerState}
StudentProgress \\
TrainingSession
\end{schema}

%==============================================================================
\section{Initialization}
%==============================================================================

A new student begins at level 1 in all directions with 1-day intervals and
no streak history. The session state initializes to an ``idle'' configuration
representing no active session.

\begin{schema}{Init}
KochTrainerState'
\where
% Persistent state initialization
receiveLevel' = minLevel \\
sendLevel' = minLevel \\
earLevel' = 1 \\
sessionCount' = 0 \\
receiveInterval' = minInterval \\
sendInterval' = minInterval \\
currentStreak' = 0 \\
longestStreak' = 0 \\
% Session state initialization (no active session)
phase' = idle \\
direction' = receive \\
radioMode' = off \\
toneActive' = zfalse \\
characterCount' = minLevel \\
introIndex' = 0 \\
sessionAttempts' = 0 \\
sessionCorrect' = 0
\end{schema}

%==============================================================================
\section{Operations}
%==============================================================================

\subsection{Level Advancement}

The Koch method's core progression: when a student achieves $\geq 90\%$ accuracy
over at least 20 attempts in a session, they advance to the next level, unlocking
one additional character.

\begin{schema}{AdvanceReceiveLevel}
\Xi TrainingSession \\
\Delta StudentProgress \\
accuracy? : \nat
\where
% Can only advance after completing a receive session
phase = completed \\
direction = receive \\
sessionAttempts > 0 \\
% Accuracy must match session results (avoiding division)
accuracy? * sessionAttempts = sessionCorrect * 100 \\
accuracy? \geq advanceThreshold \\
accuracy? \leq 100 \\
receiveLevel < maxLevel \\
receiveLevel' = receiveLevel + 1 \\
sendLevel' = sendLevel \\
earLevel' = earLevel \\
sessionCount' = sessionCount \\
receiveInterval' = receiveInterval \\
sendInterval' = sendInterval \\
currentStreak' = currentStreak \\
longestStreak' = longestStreak
\end{schema}

\begin{schema}{AdvanceSendLevel}
\Xi TrainingSession \\
\Delta StudentProgress \\
accuracy? : \nat
\where
% Can only advance after completing a send session
phase = completed \\
direction = send \\
sessionAttempts > 0 \\
% Accuracy must match session results (avoiding division)
accuracy? * sessionAttempts = sessionCorrect * 100 \\
accuracy? \geq advanceThreshold \\
accuracy? \leq 100 \\
sendLevel < maxLevel \\
sendLevel' = sendLevel + 1 \\
receiveLevel' = receiveLevel \\
earLevel' = earLevel \\
sessionCount' = sessionCount \\
receiveInterval' = receiveInterval \\
sendInterval' = sendInterval \\
currentStreak' = currentStreak \\
longestStreak' = longestStreak
\end{schema}

The precondition $receiveLevel < maxLevel$ (or $sendLevel < maxLevel$) ensures
we cannot advance beyond the 26 available characters.

\begin{schema}{AdvanceEarLevel}
\Xi TrainingSession \\
\Delta StudentProgress \\
accuracy? : \nat
\where
% Can only advance after completing a session
phase = completed \\
sessionAttempts > 0 \\
accuracy? * sessionAttempts = sessionCorrect * 100 \\
accuracy? \geq advanceThreshold \\
accuracy? \leq 100 \\
earLevel < 5 \\
earLevel' = earLevel + 1 \\
receiveLevel' = receiveLevel \\
sendLevel' = sendLevel \\
sessionCount' = sessionCount \\
receiveInterval' = receiveInterval \\
sendInterval' = sendInterval \\
currentStreak' = currentStreak \\
longestStreak' = longestStreak
\end{schema}

Ear training levels (1--5) correspond to pattern length: level 1 covers single-element
patterns (E, T), level 5 includes 5-element patterns like digits. Unlike receive/send,
ear training does not affect spaced repetition scheduling or streaks.

\subsection{Session Recording}

Each completed session increments the session count for analytics.

\begin{schema}{RecordSession}
\Xi TrainingSession \\
\Delta StudentProgress
\where
phase = completed \\
sessionCount' = sessionCount + 1 \\
receiveLevel' = receiveLevel \\
sendLevel' = sendLevel \\
earLevel' = earLevel \\
receiveInterval' = receiveInterval \\
sendInterval' = sendInterval \\
currentStreak' = currentStreak \\
longestStreak' = longestStreak
\end{schema}

\subsection{Spaced Repetition}

The interval algorithm adapts practice frequency based on performance:

\begin{center}
\begin{tabular}{ll}
\hline
Accuracy & Interval Change \\
\hline
$\geq 90\%$ & Double interval (max 30 days) \\
$70\%$--$89\%$ & No change \\
$< 70\%$ & Reset to 1 day \\
\hline
\end{tabular}
\end{center}

High accuracy indicates mastery, so we increase the interval to avoid
over-practice. Low accuracy signals struggle, so we reset to daily practice.
The middle range maintains the current schedule.

\begin{schema}{UpdateReceiveIntervalHigh}
  \Xi TrainingSession \\
  \Delta StudentProgress \\
  accuracy? : \nat \\
  daysSinceStart? : \nat
  \where
  phase = completed \\
  direction = receive \\
  sessionAttempts > 0 \\
  accuracy? * sessionAttempts = sessionCorrect * 100 \\
  accuracy? \geq advanceThreshold \\
  accuracy? \leq 100 \\
  \LET effectiveMax == \\
  \t1 \IF daysSinceStart? < habitFormationDays \\
  \t1 \THEN habitMaxInterval \\
  \t1 \ELSE maxInterval @
  (receiveInterval * 2 \leq effectiveMax \\
  \t1 \land receiveInterval' = receiveInterval * 2) \\
  \lor (receiveInterval * 2 > effectiveMax \\
  \t1 \land receiveInterval' = effectiveMax) \\
  sendInterval' = sendInterval \\
  currentStreak' = currentStreak \\
  longestStreak' = longestStreak \\
  receiveLevel' = receiveLevel \\
  sendLevel' = sendLevel \\
  earLevel' = earLevel \\
  sessionCount' = sessionCount
\end{schema}

\begin{schema}{UpdateReceiveIntervalMedium}
\Xi TrainingSession \\
\Delta StudentProgress \\
accuracy? : \nat
\where
phase = completed \\
direction = receive \\
sessionAttempts > 0 \\
accuracy? * sessionAttempts = sessionCorrect * 100 \\
accuracy? \geq 70 \\
accuracy? < advanceThreshold \\
receiveInterval' = receiveInterval \\
sendInterval' = sendInterval \\
currentStreak' = currentStreak \\
longestStreak' = longestStreak \\
receiveLevel' = receiveLevel \\
sendLevel' = sendLevel \\
earLevel' = earLevel \\
sessionCount' = sessionCount
\end{schema}

\begin{schema}{UpdateReceiveIntervalLow}
\Xi TrainingSession \\
\Delta StudentProgress \\
accuracy? : \nat
\where
phase = completed \\
direction = receive \\
sessionAttempts > 0 \\
accuracy? * sessionAttempts = sessionCorrect * 100 \\
accuracy? < 70 \\
receiveInterval' = minInterval \\
sendInterval' = sendInterval \\
currentStreak' = currentStreak \\
longestStreak' = longestStreak \\
receiveLevel' = receiveLevel \\
sendLevel' = sendLevel \\
earLevel' = earLevel \\
sessionCount' = sessionCount
\end{schema}

The three interval schemas partition the accuracy range: high ($\geq 90\%$),
medium ($70\%$--$89\%$), and low ($< 70\%$). The \emph{daysSinceStart?} input
allows the habit formation cap to be applied during the first 14 days.

Symmetric operations exist for send training:

\begin{schema}{UpdateSendIntervalHigh}
  \Xi TrainingSession \\
  \Delta StudentProgress \\
  accuracy? : \nat \\
  daysSinceStart? : \nat
  \where
  phase = completed \\
  direction = send \\
  sessionAttempts > 0 \\
  accuracy? * sessionAttempts = sessionCorrect * 100 \\
  accuracy? \geq advanceThreshold \\
  accuracy? \leq 100 \\
  \LET effectiveMax == \\
  \t1 \IF daysSinceStart? < habitFormationDays \\
  \t1 \THEN habitMaxInterval \\
  \t1 \ELSE maxInterval @
  (sendInterval * 2 \leq effectiveMax \\
  \t1 \land sendInterval' = sendInterval * 2) \\
  \lor (sendInterval * 2 > effectiveMax \\
  \t1 \land sendInterval' = effectiveMax) \\
  receiveInterval' = receiveInterval \\
  currentStreak' = currentStreak \\
  longestStreak' = longestStreak \\
  receiveLevel' = receiveLevel \\
  sendLevel' = sendLevel \\
  earLevel' = earLevel \\
  sessionCount' = sessionCount
\end{schema}

\begin{schema}{UpdateSendIntervalMedium}
\Xi TrainingSession \\
\Delta StudentProgress \\
accuracy? : \nat
\where
phase = completed \\
direction = send \\
sessionAttempts > 0 \\
accuracy? * sessionAttempts = sessionCorrect * 100 \\
accuracy? \geq 70 \\
accuracy? < advanceThreshold \\
sendInterval' = sendInterval \\
receiveInterval' = receiveInterval \\
currentStreak' = currentStreak \\
longestStreak' = longestStreak \\
receiveLevel' = receiveLevel \\
sendLevel' = sendLevel \\
earLevel' = earLevel \\
sessionCount' = sessionCount
\end{schema}

\begin{schema}{UpdateSendIntervalLow}
\Xi TrainingSession \\
\Delta StudentProgress \\
accuracy? : \nat
\where
phase = completed \\
direction = send \\
sessionAttempts > 0 \\
accuracy? * sessionAttempts = sessionCorrect * 100 \\
accuracy? < 70 \\
sendInterval' = minInterval \\
receiveInterval' = receiveInterval \\
currentStreak' = currentStreak \\
longestStreak' = longestStreak \\
receiveLevel' = receiveLevel \\
sendLevel' = sendLevel \\
earLevel' = earLevel \\
sessionCount' = sessionCount
\end{schema}

\subsection{Missed Practice Reset}

If a student misses practice for more than twice their current interval,
skill decay is assumed and the interval resets to daily practice.

\begin{schema}{ResetReceiveIntervalOnMissedPractice}
\Delta StudentProgress \\
daysSinceLastPractice? : \nat
\where
daysSinceLastPractice? > receiveInterval * missedPracticeMultiplier \\
receiveInterval' = minInterval \\
sendInterval' = sendInterval \\
currentStreak' = currentStreak \\
longestStreak' = longestStreak \\
receiveLevel' = receiveLevel \\
sendLevel' = sendLevel \\
earLevel' = earLevel \\
sessionCount' = sessionCount
\end{schema}

\begin{schema}{ResetSendIntervalOnMissedPractice}
\Delta StudentProgress \\
daysSinceLastPractice? : \nat
\where
daysSinceLastPractice? > sendInterval * missedPracticeMultiplier \\
sendInterval' = minInterval \\
receiveInterval' = receiveInterval \\
currentStreak' = currentStreak \\
longestStreak' = longestStreak \\
receiveLevel' = receiveLevel \\
sendLevel' = sendLevel \\
earLevel' = earLevel \\
sessionCount' = sessionCount
\end{schema}

\subsection{Streak Tracking}

Streaks measure consecutive calendar days with at least one completed session.
They provide motivation through gamification without affecting learning outcomes.

\begin{schema}{IncrementStreak}
  \Xi TrainingSession \\
  \Delta StudentProgress
  \where
  phase = completed \\
  currentStreak' = currentStreak + 1 \\
  (currentStreak + 1 > longestStreak \\
  \t1 \land longestStreak' = currentStreak + 1) \\
  \lor (currentStreak + 1 \leq longestStreak \\
  \t1 \land longestStreak' = longestStreak) \\
  receiveInterval' = receiveInterval \\
  sendInterval' = sendInterval \\
  receiveLevel' = receiveLevel \\
  sendLevel' = sendLevel \\
  earLevel' = earLevel \\
  sessionCount' = sessionCount
\end{schema}

The streak increments when the student practices on the calendar day following
their last practice. The longest streak updates if the current streak exceeds it.

\begin{schema}{ResetStreak}
  \Xi TrainingSession \\
  \Delta StudentProgress
  \where
  phase = completed \\
  currentStreak' = 0 \\
  longestStreak' = longestStreak \\
  receiveInterval' = receiveInterval \\
  sendInterval' = sendInterval \\
  receiveLevel' = receiveLevel \\
  sendLevel' = sendLevel \\
  earLevel' = earLevel \\
  sessionCount' = sessionCount
\end{schema}

The streak resets to zero when a calendar day passes without any practice.
Note that the longest streak is preserved---it represents the all-time record.

\subsection{Attempt Recording}

During training, each character attempt updates the per-character statistics.

\begin{schema}{RecordReceiveAttempt}
  \Xi TrainingSession \\
  \Delta CharacterStat \\
  correct? : ZBOOL
  \where
  % Can only record receive attempts during receive training
  phase = training \\
  direction = receive \\
  receiveAttempts' = receiveAttempts + 1 \\
  (correct? = ztrue \\
  \t1 \land receiveCorrect' = receiveCorrect + 1) \\
  \lor (correct? = zfalse \\
  \t1 \land receiveCorrect' = receiveCorrect) \\
  sendAttempts' = sendAttempts \\
  sendCorrect' = sendCorrect \\
  earAttempts' = earAttempts \\
  earCorrect' = earCorrect
\end{schema}

\begin{schema}{RecordSendAttempt}
  \Xi TrainingSession \\
  \Delta CharacterStat \\
  correct? : ZBOOL
  \where
  % Can only record send attempts during send training
  phase = training \\
  direction = send \\
  sendAttempts' = sendAttempts + 1 \\
  (correct? = ztrue \\
  \t1 \land sendCorrect' = sendCorrect + 1) \\
  \lor (correct? = zfalse \\
  \t1 \land sendCorrect' = sendCorrect) \\
  receiveAttempts' = receiveAttempts \\
  receiveCorrect' = receiveCorrect \\
  earAttempts' = earAttempts \\
  earCorrect' = earCorrect
\end{schema}

\begin{schema}{RecordEarAttempt}
  \Xi TrainingSession \\
  \Delta CharacterStat \\
  correct? : ZBOOL
  \where
  % Ear training requires active training phase
  % Note: Ear training is a separate mode in the app; this is simplified
  phase = training \\
  earAttempts' = earAttempts + 1 \\
  (correct? = ztrue \\
  \t1 \land earCorrect' = earCorrect + 1) \\
  \lor (correct? = zfalse \\
  \t1 \land earCorrect' = earCorrect) \\
  receiveAttempts' = receiveAttempts \\
  receiveCorrect' = receiveCorrect \\
  sendAttempts' = sendAttempts \\
  sendCorrect' = sendCorrect
\end{schema}

%==============================================================================
\section{Session Flow}
%==============================================================================

This section models the operations for training sessions. The $SessionState$
schema was defined earlier; here we specify the operations that transition
between session phases.

\subsection{Session Initialization}

\begin{schema}{InitSession}
\Xi StudentProgress \\
\Delta TrainingSession \\
direction? : Direction \\
level? : \nat
\where
% Can only start a new session when no session is active
phase \in \{idle, completed\} \\
% Level must match current progress for the chosen direction
(direction? = receive \land level? = receiveLevel) \\
\lor (direction? = send \land level? = sendLevel) \\
phase' = introduction \\
direction' = direction? \\
radioMode' = off \\
toneActive' = zfalse \\
characterCount' = level? \\
introIndex' = 0 \\
sessionAttempts' = 0 \\
sessionCorrect' = 0
\end{schema}

A session begins in the introduction phase with the radio off. The precondition
$phase = completed$ ensures we can only start a new session when no session is
active (the ``idle'' state). The radio activates when training begins
(transitioning to receiving mode).

\subsection{Introduction Phase Operations}

\begin{schema}{NextIntroCharacter}
\Delta TrainingSession
\where
phase = introduction \\
introIndex < characterCount \\
introIndex' = introIndex + 1 \\
phase' = phase \\
direction' = direction \\
radioMode' = radioMode \\
toneActive' = toneActive \\
characterCount' = characterCount \\
sessionAttempts' = sessionAttempts \\
sessionCorrect' = sessionCorrect
\end{schema}

\begin{schema}{CompleteIntroduction}
\Delta TrainingSession
\where
phase = introduction \\
introIndex = characterCount \\
phase' = training \\
radioMode' = receiving \\
toneActive' = zfalse \\
introIndex' = introIndex \\
direction' = direction \\
characterCount' = characterCount \\
sessionAttempts' = sessionAttempts \\
sessionCorrect' = sessionCorrect
\end{schema}

When all characters have been shown ($introIndex = characterCount$), the
session transitions to the training phase and the radio turns on in receiving mode.

\subsection{Training Phase Operations}

During training, the student responds to character prompts. Each response
(correct, incorrect, or timeout) is recorded.

\begin{schema}{RecordCorrectResponse}
\Delta TrainingSession
\where
phase = training \\
sessionAttempts' = sessionAttempts + 1 \\
sessionCorrect' = sessionCorrect + 1 \\
phase' = phase \\
direction' = direction \\
radioMode' = radioMode \\
toneActive' = toneActive \\
characterCount' = characterCount \\
introIndex' = introIndex
\end{schema}

\begin{schema}{RecordIncorrectResponse}
\Delta TrainingSession
\where
phase = training \\
sessionAttempts' = sessionAttempts + 1 \\
sessionCorrect' = sessionCorrect \\
phase' = phase \\
direction' = direction \\
radioMode' = radioMode \\
toneActive' = toneActive \\
characterCount' = characterCount \\
introIndex' = introIndex
\end{schema}

A timeout is treated as an incorrect response---the student failed to respond
within \emph{responseTimeoutMs} (3 seconds).

\subsection{Pause and Resume}

\begin{schema}{PauseSession}
\Delta TrainingSession
\where
phase = training \\
phase' = paused \\
radioMode' = off \\
toneActive' = zfalse \\
direction' = direction \\
characterCount' = characterCount \\
introIndex' = introIndex \\
sessionAttempts' = sessionAttempts \\
sessionCorrect' = sessionCorrect
\end{schema}

\begin{schema}{ResumeSession}
\Delta TrainingSession
\where
phase = paused \\
phase' = training \\
radioMode' = receiving \\
toneActive' = zfalse \\
direction' = direction \\
characterCount' = characterCount \\
introIndex' = introIndex \\
sessionAttempts' = sessionAttempts \\
sessionCorrect' = sessionCorrect
\end{schema}

Pausing turns the radio off. Resuming returns to receiving mode (the radio
turns back on, listening for incoming signals).

\subsection{Radio Mode Transitions}

During send training, the student toggles between receiving (waiting to key)
and transmitting (actively keying). These transitions model the half-duplex
nature of amateur radio.

\begin{schema}{EnterTransmitMode}
\Delta TrainingSession
\where
phase = training \\
direction = send \\
radioMode = receiving \\
radioMode' = transmitting \\
toneActive' = toneActive \\
phase' = phase \\
direction' = direction \\
characterCount' = characterCount \\
introIndex' = introIndex \\
sessionAttempts' = sessionAttempts \\
sessionCorrect' = sessionCorrect
\end{schema}

\begin{schema}{ExitTransmitMode}
\Delta TrainingSession
\where
phase = training \\
direction = send \\
radioMode = transmitting \\
radioMode' = receiving \\
toneActive' = zfalse \\
phase' = phase \\
direction' = direction \\
characterCount' = characterCount \\
introIndex' = introIndex \\
sessionAttempts' = sessionAttempts \\
sessionCorrect' = sessionCorrect
\end{schema}

$EnterTransmitMode$ occurs when the student begins keying (presses dit or dah).
$ExitTransmitMode$ occurs when keying completes (timeout after last element).
Note that transmitting is only valid during send training---the precondition
$direction = send$ enforces this constraint.

\subsection{Tone Activation}

During training, Morse tones are generated by activating and deactivating the
tone generator. The \emph{toneActive} flag controls whether audio is currently
being produced. The audio output depends on the current radio mode:

\begin{itemize}
\item \emph{receiving}: Tone mixed with noise floor and band conditions (QRN, QSB, QRM)
\item \emph{transmitting}: Clean sidetone only (no noise or band conditions)
\item \emph{off}: No audio output (toneActive must be false)
\end{itemize}

\begin{schema}{ActivateTone}
\Delta TrainingSession
\where
radioMode = transmitting \\
toneActive = zfalse \\
toneActive' = ztrue \\
phase' = phase \\
direction' = direction \\
radioMode' = radioMode \\
characterCount' = characterCount \\
introIndex' = introIndex \\
sessionAttempts' = sessionAttempts \\
sessionCorrect' = sessionCorrect
\end{schema}

$ActivateTone$ requires the radio to be transmitting---modeling half-duplex
behavior where sidetone is only generated when the operator keys.
The precondition $toneActive = zfalse$ prevents double activation.

\begin{schema}{DeactivateTone}
\Delta TrainingSession
\where
toneActive = ztrue \\
toneActive' = zfalse \\
phase' = phase \\
direction' = direction \\
radioMode' = radioMode \\
characterCount' = characterCount \\
introIndex' = introIndex \\
sessionAttempts' = sessionAttempts \\
sessionCorrect' = sessionCorrect
\end{schema}

$DeactivateTone$ stops tone generation. The precondition $toneActive = ztrue$
ensures we only deactivate an active tone.

In the implementation, \texttt{playToneElement(duration:)} performs:
\begin{enumerate}
\item $ActivateTone$ (start generating tone at configured frequency)
\item Wait for the specified duration (dit: 60ms, dah: 180ms)
\item $DeactivateTone$ (stop tone generation)
\end{enumerate}

The continuous audio engine ensures smooth transitions---the audio buffer runs
continuously, and only the tone generation flag changes, avoiding clicks or pops
from starting/stopping the audio engine.

\subsection{Proficiency Check}

The session ends automatically when the student achieves proficiency:
$\geq 90\%$ accuracy over at least $\max(15, 5 \times characterCount)$ attempts.

\begin{schema}{CheckProficiencyMet}
  \Xi TrainingSession \\
  proficiencyMet! : ZBOOL
  \where
  phase = training \\
  sessionAttempts > 0 \\
  \LET minAttempts == \\
  \t1 \IF baseMinimumAttempts \\
  \t2 > attemptsPerCharacter * characterCount \\
  \t1 \THEN baseMinimumAttempts \\
  \t1 \ELSE attemptsPerCharacter * characterCount @
  \LET accuracyPercent == \\
  \t1 (sessionCorrect * 100) \div sessionAttempts @
  (sessionAttempts \geq minAttempts \\
  \t1 \land accuracyPercent \geq proficiencyThreshold \\
  \t1 \land proficiencyMet! = ztrue) \\
  \lor (sessionAttempts < minAttempts \\
  \t1 \land proficiencyMet! = zfalse) \\
  \lor (accuracyPercent < proficiencyThreshold \\
  \t1 \land proficiencyMet! = zfalse)
\end{schema}

This is a query operation ($\Xi$ indicates no state change). The implementation
calls this after each response to determine whether to end the session.

\subsection{Session Completion}

\begin{schema}{CompleteSession}
\Delta TrainingSession
\where
phase = training \\
phase' = completed \\
radioMode' = off \\
toneActive' = zfalse \\
direction' = direction \\
characterCount' = characterCount \\
introIndex' = introIndex \\
sessionAttempts' = sessionAttempts \\
sessionCorrect' = sessionCorrect
\end{schema}

When a session completes (either by proficiency or user action), the radio
turns off and the accumulated statistics are transferred to persistent state
via $RecordSession$ and the relevant $Advance$ and $UpdateInterval$ operations.

\subsection{Session-to-Progress Integration}

The session flow connects to persistent progress through these operations:

\begin{enumerate}
\item On session completion, calculate accuracy: $sessionCorrect \div sessionAttempts$
\item If accuracy $\geq 90\%$: invoke $AdvanceReceiveLevel$ or $AdvanceSendLevel$
\item Based on accuracy tier: invoke appropriate $UpdateInterval$ operation
\item Invoke $RecordSession$ to increment session count
\item Update streak via $IncrementStreak$ or $ResetStreak$ based on calendar day
\end{enumerate}

This integration is orchestrated by the application layer (ProgressStore in the
implementation) rather than modeled as a single composite operation.

%==============================================================================
\section{System Invariants}
%==============================================================================

The following properties hold for any reachable state:

\begin{enumerate}
\item \textbf{Level bounds}: $1 \leq receiveLevel \leq 26$ and
      $1 \leq sendLevel \leq 26$

\item \textbf{Correctness bounds}: For any character,
      $receiveCorrect \leq receiveAttempts$ and
      $sendCorrect \leq sendAttempts$

\item \textbf{Streak monotonicity}: $currentStreak \leq longestStreak$

\item \textbf{Interval bounds}: $1 \leq interval \leq 30$ for both directions

\item \textbf{Non-negative counts}: All attempt and session counts are
      non-negative natural numbers
\end{enumerate}

These invariants are encoded directly in the schema predicates, ensuring
type-correct operations preserve them.

%==============================================================================
\section{Properties Not Modeled}
%==============================================================================

This specification focuses on state that affects learning outcomes. The following
aspects are intentionally omitted:

\begin{itemize}
\item \textbf{Audio timing}: Dit/dah durations (60ms/180ms at 20 WPM),
      Farnsworth spacing adjustments

\item \textbf{QSO simulation}: Virtual station exchanges, protocol phases,
      message templates

\item \textbf{UI state}: Current screen, selected characters, input buffers

\item \textbf{Notifications}: Practice due reminders, streak alerts,
      anti-nag policies
\end{itemize}

These could be modeled in future extensions or separate specifications.

%==============================================================================
\section{Validation}
%==============================================================================

This specification has been validated with:

\begin{itemize}
\item \textbf{fuzz}: Type-checking passes with no errors
\item \textbf{probcli -init}: Initialization succeeds
\item \textbf{probcli -cbc\_deadlock}: No deadlock states found
\item \textbf{probcli -cbc\_assertions}: All assertions hold
\end{itemize}

The $MODEL\_BOUND$ constant (currently 3) enables finite model checking. Increase
this value for more thorough exploration at the cost of longer runtimes. The
unbounded given sets (SESSIONID, TIMESTAMP) can be constrained using probcli's
\texttt{-p DEFAULT\_SETSIZE} option.

\end{document}
